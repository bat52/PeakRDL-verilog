{%- import 'addressable.sv' as addressable with context -%}

// This file was autogenerated by PeakRDL-verilog
module {{get_inst_name(top_node)}}_tb #(
    parameter                                ADDR_OFFSET = 'h0,  // Module's offset in the main address map
    parameter                                ADDR_WIDTH  = 32,   // Width of SW address bus
    parameter                                DATA_WIDTH  = 32    // Width of SW data bus
);
    // Clocks and resets
    logic                              clk;
    logic                              resetn;

{%- for node in top_node.descendants() -%}
{%- if isinstance(node, RegNode) %}

    // Register {{get_inst_name(node).upper()}}
    logic {{node.full_array_ranges}}        {{signal(node)}}_strb;

{%- elif isinstance(node, FieldNode) -%}
{%- if node.is_hw_writable %}
    logic {{node.parent.full_array_ranges}}        {{signal(node)}}_wr;
    logic {{node.parent.full_array_ranges}}[{{node.bit_range}}] {{signal(node)}}_wdata;

{%- endif -%}
{%- if node.is_hw_readable %}
    logic {{node.parent.full_array_ranges}}[{{node.bit_range}}] {{signal(node)}}_q;

{%- endif -%}
{%- if node.get_property('counter') %}
    logic {{node.parent.full_array_ranges}}        {{signal(node)}}_incr;

{%- endif -%}
{%- endif -%}
{%- endfor %}

    // Register Bus
    logic                             valid;    // active high
    logic                             read;     // indicates request is a read
    logic            [ADDR_WIDTH-1:0] addr;     // address (byte aligned, absolute address)
    logic            [DATA_WIDTH-1:0] wdata;    // write data
    logic          [DATA_WIDTH/8-1:0] wmask;    // write mask
    logic            [DATA_WIDTH-1:0] rdata;    // read data

    initial begin
        resetn <= 1'b0;
        #20 @(posedge clk) resetn <= 1'b1;
        $display("%t: TB: reset complete", $time());
    end
    initial begin
        clk <= 1'b0;
        forever #5 clk <= ~clk;
    end

    {{get_inst_name(top_node)}} #(
        .ADDR_OFFSET(ADDR_OFFSET),
        .ADDR_WIDTH (ADDR_WIDTH),
        .DATA_WIDTH (DATA_WIDTH)
    ) dut (.*);

    initial begin
        // init all hw inputs
{%- for node in top_node.descendants() -%}
{%- if isinstance(node, FieldNode) %}
{%- if node.is_hw_writable %}
        {{signal(node)}}_wr <= '0;
        {{signal(node)}}_wdata <= '0;
{%- endif -%}
{%- if node.get_property('counter') %}
        {{signal(node)}}_incr <= '0;
{%- endif -%}
{%- endif -%}
{%- endfor %}

        // init all sw input
        valid <= '0;
        read <= '0;
        addr <= '0;
        wdata <= '0;
        wmask <= '1;

        @(posedge resetn);


{%- for node in top_node.descendants(unroll=True) -%}
{%- if isinstance(node, FieldNode) %}
        repeat(5) @(posedge clk);
        $display("%t: Testcase ({{signal(node)}} {{full_idx(node.parent)}}):", $time());
    {%- if node.is_hw_writable %}
        // HW write - SW read
        for (int IDX = {{node.lsb}}; IDX <= {{node.msb}}; ++IDX) begin
            $display("%t:\tWrite bit %0d high", $time(), IDX);
            {{signal(node)}}_wr{{full_idx(node.parent)}} <= 1'b1;
            {{signal(node)}}_wdata{{full_idx(node.parent)}}[IDX] <= 1'b1;
            @(posedge clk);
            {{signal(node)}}_wr <= '0;

            valid <= 1'b1;
            read <= 1'b1;
            addr <= {{node.parent.absolute_address}};
            @(posedge clk);
            valid <= 1'b0;
            assert(rdata[{{node.bit_range}}] == (1 << (IDX-{{node.lsb}}))) else
                $fatal("MISMATCH %x != %x", rdata[{{node.bit_range}}], (1 << (IDX-{{node.lsb}})));

            $display("%t:\tWrite bit %0d low", $time(), IDX);
            {{signal(node)}}_wr{{full_idx(node.parent)}} <= 1'b1;
            {{signal(node)}}_wdata{{full_idx(node.parent)}}[IDX] <= 1'b0;
            @(posedge clk);
            {{signal(node)}}_wr <= '0;

            valid <= 1'b1;
            read <= 1'b1;
            addr <= {{node.parent.absolute_address}};
            @(posedge clk);
            valid <= 1'b0;
            assert(rdata[{{node.bit_range}}] == 0) else
                $fatal("MISMATCH %x != %x", rdata[{{node.bit_range}}], 0);
        end
    {%- endif -%}
    {%- if node.is_hw_readable and node.is_sw_writable %}
        for (int IDX = {{node.lsb}}; IDX <= {{node.msb}}; ++IDX) begin

            $display("%t:\tRead bit %0d high", $time(), IDX);
            valid <= 1'b1;
            read <= 1'b0;
            addr <= {{node.parent.absolute_address}};
            wdata <= (1 << IDX);
            @(posedge clk);
            valid <= 1'b0;
            #1;
            assert({{signal(node)}}_q{{full_idx(node.parent)}} == (1 << (IDX-{{node.lsb}}))) else
                $fatal("MISMATCH %x != %x", {{signal(node)}}_q{{full_idx(node.parent)}}, (1 << (IDX-{{node.lsb}})));

            $display("%t:\tRead bit %0d low", $time(), IDX);
            valid <= 1'b1;
            read <= 1'b0;
            addr <= {{node.parent.absolute_address}};
            wdata <= '0;
            @(posedge clk);
            valid <= 1'b0;
            #1;
            assert({{signal(node)}}_q{{full_idx(node.parent)}} == '0) else
                $fatal("MISMATCH %x != %x", {{signal(node)}}_q{{full_idx(node.parent)}}, '0);
        end
    {%- endif -%}
    {%- if node.get_property('counter') %}
    {%- endif -%}
{%- endif -%}
{%- endfor %}

        #200;
        $display("%t: TB: test complete", $time());
        $finish();
    end

endmodule: {{get_inst_name(top_node)}}_tb

