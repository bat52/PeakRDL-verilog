
addrmap counter #(longint unsigned PARAM = 0x10) {

    reg {
        default sw = rw;
        default hw = rw;
        field {} basicfield[31:0];
    } basicreg;

    reg {
        default sw = rw;
        default hw = r;

        // 9.8.1 Example 1
        field counter_f { counter; };
        counter_f count1[4]; // Define a 4 bit counter from 3 down to 0
        count1->incrvalue=3; // Increment the counter by 3 when incrementing
                                // count1 implies an UP counter
        counter_f count2[3]; // Define a 3 bit counter from 6 down to 4
        count2->decrwidth=2; // provide 2 bit interface for a user to decide the decr
                                // value. This implies a down counter.
        counter_f count3[5]=0; // Defines a 5 bit counter from 11 down to 7
        count3->incrvalue=2; // Define a an Up/Down Counter
        count3->decrvalue=4;
        field {} count4_incr[8] = 8'h0f; // define a field to control the incr
                                // value of another field.
        counter_f count4[8]=0;
        count4->incrvalue = count4_incr; // Counter is incremented by the valu
    } count[2];

    // 9.8.1 Example 2
    field some_counter {
        counter;
        we;
    }; // End of Reg: some_counter

    reg some_counter_reg {
        regwidth=16;
        some_counter count[16]=0; // Create 16 bit counter POR to 0
    }; // End of Reg:

    // Example 32 bit up counter
    some_counter_reg count1_low;
    some_counter_reg count1_high;

    count1_high.count->incr = count1_low.count->overflow;
    // Daisy chain the counters together to create a 32 bit counter from the 2
    // 16 bit countersV
};
